"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const result_1 = require("@badrap/result");
const types_1 = require("./types");
const squareSet_1 = require("./squareSet");
const board_1 = require("./board");
const setup_1 = require("./setup");
const util_1 = require("./util");
exports.INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
exports.INITIAL_EPD = exports.INITIAL_BOARD_FEN + ' w KQkq -';
exports.INITIAL_FEN = exports.INITIAL_EPD + ' 0 1';
exports.EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';
exports.EMPTY_EPD = exports.EMPTY_BOARD_FEN + ' w - -';
exports.EMPTY_FEN = exports.EMPTY_EPD + ' 0 1';
var InvalidFen;
(function (InvalidFen) {
    InvalidFen["Fen"] = "ERR_FEN";
    InvalidFen["Board"] = "ERR_BOARD";
    InvalidFen["Pockets"] = "ERR_POCKETS";
    InvalidFen["Turn"] = "ERR_TURN";
    InvalidFen["Castling"] = "ERR_CASTLING";
    InvalidFen["EpSquare"] = "ERR_EP_SQUARE";
    InvalidFen["RemainingChecks"] = "ERR_REMAINING_CHECKS";
    InvalidFen["Halfmoves"] = "ERR_HALFMOVES";
    InvalidFen["Fullmoves"] = "ERR_FULLMOVES";
})(InvalidFen = exports.InvalidFen || (exports.InvalidFen = {}));
class FenError extends Error {
}
exports.FenError = FenError;
function nthIndexOf(haystack, needle, n) {
    let index = haystack.indexOf(needle);
    while (n-- > 0) {
        if (index === -1)
            break;
        index = haystack.indexOf(needle, index + needle.length);
    }
    return index;
}
function parseSmallUint(str) {
    return /^\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined;
}
function charToPiece(ch) {
    const role = util_1.charToRole(ch);
    return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };
}
function parseBoardFen(boardPart) {
    const board = board_1.Board.empty();
    let rank = 7;
    let file = 0;
    for (let i = 0; i < boardPart.length; i++) {
        const c = boardPart[i];
        if (c === '/' && file === 8) {
            file = 0;
            rank--;
        }
        else {
            const step = parseInt(c, 10);
            if (step)
                file += step;
            else {
                if (file >= 8 || rank < 0)
                    return result_1.Result.err(new FenError(InvalidFen.Board));
                const square = file + rank * 8;
                const piece = charToPiece(c);
                if (!piece)
                    return result_1.Result.err(new FenError(InvalidFen.Board));
                if (boardPart[i + 1] === '~') {
                    piece.promoted = true;
                    i++;
                }
                board.set(square, piece);
                file++;
            }
        }
    }
    if (rank !== 0 || file !== 8)
        return result_1.Result.err(new FenError(InvalidFen.Board));
    return result_1.Result.ok(board);
}
exports.parseBoardFen = parseBoardFen;
function parsePockets(pocketPart) {
    if (pocketPart.length > 64)
        return result_1.Result.err(new FenError(InvalidFen.Pockets));
    const pockets = setup_1.Material.empty();
    for (const c of pocketPart) {
        const piece = charToPiece(c);
        if (!piece)
            return result_1.Result.err(new FenError(InvalidFen.Pockets));
        pockets[piece.color][piece.role]++;
    }
    return result_1.Result.ok(pockets);
}
exports.parsePockets = parsePockets;
function parseCastlingFen(board, castlingPart) {
    let unmovedRooks = squareSet_1.SquareSet.empty();
    if (castlingPart === '-')
        return result_1.Result.ok(unmovedRooks);
    if (!/^[KQABCDEFGH]{0,2}[kqabcdefgh]{0,2}$/.test(castlingPart)) {
        return result_1.Result.err(new FenError(InvalidFen.Castling));
    }
    for (const c of castlingPart) {
        const lower = c.toLowerCase();
        const color = c === lower ? 'black' : 'white';
        const backrank = squareSet_1.SquareSet.backrank(color).intersect(board[color]);
        let candidates;
        if (lower === 'q')
            candidates = backrank;
        else if (lower === 'k')
            candidates = backrank.reversed();
        else
            candidates = squareSet_1.SquareSet.fromSquare(lower.charCodeAt(0) - 'a'.charCodeAt(0)).intersect(backrank);
        for (const square of candidates) {
            if (board.king.has(square) && !board.promoted.has(square))
                break;
            if (board.rook.has(square)) {
                unmovedRooks = unmovedRooks.with(square);
                break;
            }
        }
    }
    return result_1.Result.ok(unmovedRooks);
}
exports.parseCastlingFen = parseCastlingFen;
function parseRemainingChecks(part) {
    const parts = part.split('+');
    if (parts.length === 3 && parts[0] === '') {
        const white = parseSmallUint(parts[1]);
        const black = parseSmallUint(parts[2]);
        if (!util_1.defined(white) || white > 3 || !util_1.defined(black) || black > 3)
            return result_1.Result.err(new FenError(InvalidFen.RemainingChecks));
        return result_1.Result.ok(new setup_1.RemainingChecks(3 - white, 3 - black));
    }
    else if (parts.length === 2) {
        const white = parseSmallUint(parts[0]);
        const black = parseSmallUint(parts[1]);
        if (!util_1.defined(white) || white > 3 || !util_1.defined(black) || black > 3)
            return result_1.Result.err(new FenError(InvalidFen.RemainingChecks));
        return result_1.Result.ok(new setup_1.RemainingChecks(white, black));
    }
    else
        return result_1.Result.err(new FenError(InvalidFen.RemainingChecks));
}
exports.parseRemainingChecks = parseRemainingChecks;
function parseFen(fen) {
    const parts = fen.split(' ');
    const boardPart = parts.shift();
    // Board and pockets
    let board, pockets = result_1.Result.ok(undefined);
    if (boardPart.endsWith(']')) {
        const pocketStart = boardPart.indexOf('[');
        if (pocketStart === -1)
            return result_1.Result.err(new FenError(InvalidFen.Fen));
        board = parseBoardFen(boardPart.substr(0, pocketStart));
        pockets = parsePockets(boardPart.substr(pocketStart + 1, boardPart.length - 1 - pocketStart - 1));
    }
    else {
        const pocketStart = nthIndexOf(boardPart, '/', 7);
        if (pocketStart === -1)
            board = parseBoardFen(boardPart);
        else {
            board = parseBoardFen(boardPart.substr(0, pocketStart));
            pockets = parsePockets(boardPart.substr(pocketStart + 1));
        }
    }
    // Turn
    let turn;
    const turnPart = parts.shift();
    if (!util_1.defined(turnPart) || turnPart === 'w')
        turn = 'white';
    else if (turnPart === 'b')
        turn = 'black';
    else
        return result_1.Result.err(new FenError(InvalidFen.Turn));
    return board.chain(board => {
        // Castling
        const castlingPart = parts.shift();
        const unmovedRooks = util_1.defined(castlingPart) ? parseCastlingFen(board, castlingPart) : result_1.Result.ok(squareSet_1.SquareSet.empty());
        // En passant square
        const epPart = parts.shift();
        let epSquare;
        if (util_1.defined(epPart) && epPart !== '-') {
            epSquare = util_1.parseSquare(epPart);
            if (!util_1.defined(epSquare))
                return result_1.Result.err(new FenError(InvalidFen.EpSquare));
        }
        // Halfmoves or remaining checks
        let halfmovePart = parts.shift();
        let earlyRemainingChecks;
        if (util_1.defined(halfmovePart) && halfmovePart.includes('+')) {
            earlyRemainingChecks = parseRemainingChecks(halfmovePart);
            halfmovePart = parts.shift();
        }
        const halfmoves = util_1.defined(halfmovePart) ? parseSmallUint(halfmovePart) : 0;
        if (!util_1.defined(halfmoves))
            return result_1.Result.err(new FenError(InvalidFen.Halfmoves));
        const fullmovesPart = parts.shift();
        const fullmoves = util_1.defined(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;
        if (!util_1.defined(fullmoves))
            return result_1.Result.err(new FenError(InvalidFen.Fullmoves));
        const remainingChecksPart = parts.shift();
        let remainingChecks = result_1.Result.ok(undefined);
        if (util_1.defined(remainingChecksPart)) {
            if (util_1.defined(earlyRemainingChecks))
                return result_1.Result.err(new FenError(InvalidFen.RemainingChecks));
            remainingChecks = parseRemainingChecks(remainingChecksPart);
        }
        else if (util_1.defined(earlyRemainingChecks)) {
            remainingChecks = earlyRemainingChecks;
        }
        ;
        if (parts.length)
            return result_1.Result.err(new FenError(InvalidFen.Fen));
        return pockets.chain(pockets => unmovedRooks.chain(unmovedRooks => remainingChecks.map(remainingChecks => {
            return {
                board,
                pockets,
                turn,
                unmovedRooks,
                remainingChecks,
                epSquare,
                halfmoves,
                fullmoves: Math.max(1, fullmoves)
            };
        })));
    });
}
exports.parseFen = parseFen;
function parsePiece(str) {
    if (!str)
        return;
    const piece = charToPiece(str[0]);
    if (!piece)
        return;
    if (str.length === 2 && str[1] === '~')
        piece.promoted = true;
    else if (str.length > 1)
        return;
    return piece;
}
exports.parsePiece = parsePiece;
function makePiece(piece, opts) {
    let r = util_1.roleToChar(piece.role);
    if (piece.color === 'white')
        r = r.toUpperCase();
    if (opts && opts.promoted && piece.promoted)
        r += '~';
    return r;
}
exports.makePiece = makePiece;
function makeBoardFen(board, opts) {
    let fen = '';
    let empty = 0;
    for (let rank = 7; rank >= 0; rank--) {
        for (let file = 0; file < 8; file++) {
            const square = file + rank * 8;
            const piece = board.get(square);
            if (!piece)
                empty++;
            else {
                if (empty) {
                    fen += empty;
                    empty = 0;
                }
                fen += makePiece(piece, opts);
            }
            if (file === 7) {
                if (empty) {
                    fen += empty;
                    empty = 0;
                }
                if (rank !== 0)
                    fen += '/';
            }
        }
    }
    return fen;
}
exports.makeBoardFen = makeBoardFen;
function makePocket(material) {
    return types_1.ROLES.map(role => util_1.roleToChar(role).repeat(material[role])).join('');
}
function makePockets(pocket) {
    return makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);
}
exports.makePockets = makePockets;
function makeCastlingFen(board, unmovedRooks, opts) {
    const shredder = opts && opts.shredder;
    let fen = '';
    for (const color of types_1.COLORS) {
        const backrank = squareSet_1.SquareSet.backrank(color);
        const king = board.kingOf(color);
        if (!util_1.defined(king) || !backrank.has(king))
            continue;
        const candidates = board.pieces(color, 'rook').intersect(backrank);
        for (const rook of unmovedRooks.intersect(candidates).reversed()) {
            if (!shredder && rook === candidates.first() && rook < king) {
                fen += color === 'white' ? 'Q' : 'q';
            }
            else if (!shredder && rook === candidates.last() && king < rook) {
                fen += color === 'white' ? 'K' : 'k';
            }
            else {
                fen += (color === 'white' ? 'ABCDEFGH' : 'abcdefgh')[rook & 0x7];
            }
        }
    }
    return fen || '-';
}
exports.makeCastlingFen = makeCastlingFen;
function makeRemainingChecks(checks) {
    return `${checks.white}+${checks.black}`;
}
exports.makeRemainingChecks = makeRemainingChecks;
function makeFen(setup, opts) {
    return [
        makeBoardFen(setup.board, opts) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),
        setup.turn[0],
        makeCastlingFen(setup.board, setup.unmovedRooks, opts),
        util_1.defined(setup.epSquare) ? util_1.makeSquare(setup.epSquare) : '-',
        ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),
        ...(opts && opts.epd ? [] : [setup.halfmoves, setup.fullmoves])
    ].join(' ');
}
exports.makeFen = makeFen;
