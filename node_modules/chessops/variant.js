"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const result_1 = require("@badrap/result");
const types_1 = require("./types");
const util_1 = require("./util");
const attacks_1 = require("./attacks");
const squareSet_1 = require("./squareSet");
const board_1 = require("./board");
const setup_1 = require("./setup");
const chess_1 = require("./chess");
exports.PositionError = chess_1.PositionError;
exports.Position = chess_1.Position;
exports.IllegalSetup = chess_1.IllegalSetup;
exports.Castles = chess_1.Castles;
exports.Chess = chess_1.Chess;
class Crazyhouse extends chess_1.Chess {
    constructor() {
        super('crazyhouse');
    }
    static default() {
        const pos = super.default();
        pos.pockets = setup_1.Material.empty();
        return pos;
    }
    static fromSetup(setup) {
        return super.fromSetup(setup).map(pos => {
            pos.pockets = setup.pockets ? setup.pockets.clone() : setup_1.Material.empty();
            return pos;
        });
    }
    validate() {
        return super.validate().chain(_ => {
            if (this.pockets && (this.pockets.white.king > 0 || this.pockets.black.king > 0)) {
                return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Kings));
            }
            if ((this.pockets ? this.pockets.count() : 0) + this.board.occupied.size() > 64) {
                return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Variant));
            }
            return result_1.Result.ok(undefined);
        });
    }
    clone() {
        return super.clone();
    }
    hasInsufficientMaterial(color) {
        // No material can leave the game, but we can easily check this for
        // custom positions.
        if (!this.pockets)
            return super.hasInsufficientMaterial(color);
        return this.board.occupied.size() + this.pockets.count() <= 3 &&
            this.board.pawn.isEmpty() &&
            this.board.promoted.isEmpty() &&
            this.board.rooksAndQueens().isEmpty() &&
            this.pockets.white.pawn <= 0 &&
            this.pockets.black.pawn <= 0 &&
            this.pockets.white.rook <= 0 &&
            this.pockets.black.rook <= 0 &&
            this.pockets.white.queen <= 0 &&
            this.pockets.black.queen <= 0;
    }
    dropDests(ctx) {
        const mask = this.board.occupied.complement().intersect((this.pockets && this.pockets[this.turn].hasNonPawns()) ? squareSet_1.SquareSet.full() :
            (this.pockets && this.pockets[this.turn].pawn) ? squareSet_1.SquareSet.backranks().complement() :
                squareSet_1.SquareSet.empty());
        if (util_1.defined(ctx.king) && ctx.checkers.nonEmpty()) {
            const checker = ctx.checkers.singleSquare();
            if (!util_1.defined(checker))
                return squareSet_1.SquareSet.empty();
            return mask.intersect(attacks_1.between(checker, ctx.king));
        }
        else
            return mask;
    }
}
exports.Crazyhouse = Crazyhouse;
class Atomic extends chess_1.Chess {
    constructor() {
        super('atomic');
    }
    static default() {
        return super.default();
    }
    static fromSetup(setup) {
        return super.fromSetup(setup);
    }
    clone() {
        return super.clone();
    }
    validate() {
        // Like chess, but allow our king to be missing.
        if (this.board.occupied.isEmpty())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Empty));
        if (this.board.king.size() > 2)
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Kings));
        const otherKing = this.board.kingOf(util_1.opposite(this.turn));
        if (!util_1.defined(otherKing))
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Kings));
        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.OppositeCheck));
        }
        if (squareSet_1.SquareSet.backranks().intersects(this.board.pawn)) {
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.PawnsOnBackrank));
        }
        return result_1.Result.ok(undefined);
    }
    kingAttackers(square, attacker, occupied) {
        if (attacks_1.kingAttacks(square).intersects(this.board.pieces(attacker, 'king'))) {
            return squareSet_1.SquareSet.empty();
        }
        return super.kingAttackers(square, attacker, occupied);
    }
    playCaptureAt(square, captured) {
        super.playCaptureAt(square, captured);
        this.board.take(square);
        for (const explode of attacks_1.kingAttacks(square).intersect(this.board.occupied).diff(this.board.pawn)) {
            const piece = this.board.take(explode);
            if (piece && piece.role === 'rook')
                this.castles.discardRook(explode);
            if (piece && piece.role === 'king')
                this.castles.discardSide(piece.color);
        }
    }
    hasInsufficientMaterial(color) {
        // Remaining material does not matter if the enemy king is already
        // exploded.
        if (this.board.pieces(util_1.opposite(color), 'king').isEmpty())
            return false;
        // Bare king cannot mate.
        if (this.board[color].diff(this.board.king).isEmpty())
            return true;
        // As long as the enemy king is not alone, there is always a chance their
        // own pieces explode next to it.
        if (this.board[util_1.opposite(color)].diff(this.board.king).nonEmpty()) {
            // Unless there are only bishops that cannot explode each other.
            if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {
                if (!this.board.bishop.intersect(this.board.white).intersects(squareSet_1.SquareSet.darkSquares())) {
                    return !this.board.bishop.intersect(this.board.black).intersects(squareSet_1.SquareSet.lightSquares());
                }
                if (!this.board.bishop.intersect(this.board.white).intersects(squareSet_1.SquareSet.lightSquares())) {
                    return !this.board.bishop.intersect(this.board.black).intersects(squareSet_1.SquareSet.darkSquares());
                }
            }
            return false;
        }
        // Queen or pawn (future queen) can give mate against bare king.
        if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty())
            return false;
        // Single knight, bishop or rook cannot mate against bare king.
        if (this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare())
            return true;
        // If only knights, more than two are required to mate bare king.
        if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {
            return this.board.knight.size() <= 2;
        }
        return false;
    }
    dests(square, ctx) {
        let dests = squareSet_1.SquareSet.empty();
        for (const to of this.pseudoDests(square, ctx)) {
            const after = this.clone();
            after.play({ from: square, to });
            const ourKing = after.board.kingOf(this.turn);
            if (util_1.defined(ourKing) && (!util_1.defined(after.board.kingOf(after.turn)) || after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())) {
                dests = dests.with(to);
            }
        }
        return dests;
    }
    isVariantEnd() {
        return !!this.variantOutcome();
    }
    variantOutcome() {
        for (const color of types_1.COLORS) {
            if (this.board.pieces(color, 'king').isEmpty())
                return { winner: util_1.opposite(color) };
        }
        return;
    }
}
exports.Atomic = Atomic;
class Antichess extends chess_1.Chess {
    constructor() {
        super('antichess');
    }
    static default() {
        const pos = new this();
        pos.board = board_1.Board.default();
        pos.turn = 'white';
        pos.castles = chess_1.Castles.empty();
        pos.epSquare = undefined;
        pos.remainingChecks = undefined;
        pos.halfmoves = 0;
        pos.fullmoves = 1;
        return pos;
    }
    static fromSetup(setup) {
        return super.fromSetup(setup).map(pos => {
            pos.castles = chess_1.Castles.empty();
            return pos;
        });
    }
    clone() {
        return super.clone();
    }
    validate() {
        if (this.board.occupied.isEmpty())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Empty));
        if (squareSet_1.SquareSet.backranks().intersects(this.board.pawn))
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.PawnsOnBackrank));
        return result_1.Result.ok(undefined);
    }
    kingAttackers(_square, _attacker, _occupied) {
        return squareSet_1.SquareSet.empty();
    }
    ctx() {
        const ctx = super.ctx();
        const enemy = this.board[util_1.opposite(this.turn)];
        for (const from of this.board[this.turn]) {
            if (this.pseudoDests(from, ctx).intersects(enemy)) {
                ctx.mustCapture = true;
                break;
            }
        }
        return ctx;
    }
    dests(square, ctx) {
        const dests = this.pseudoDests(square, ctx);
        if (!ctx.mustCapture)
            return dests;
        else
            return dests.intersect(this.board[util_1.opposite(this.turn)]);
    }
    hasInsufficientMaterial(color) {
        if (this.board.occupied.equals(this.board.bishop)) {
            const weSomeOnLight = this.board[color].intersects(squareSet_1.SquareSet.lightSquares());
            const weSomeOnDark = this.board[color].intersects(squareSet_1.SquareSet.darkSquares());
            const theyAllOnDark = this.board[util_1.opposite(color)].isDisjoint(squareSet_1.SquareSet.lightSquares());
            const theyAllOnLight = this.board[util_1.opposite(color)].isDisjoint(squareSet_1.SquareSet.darkSquares());
            return (weSomeOnLight && theyAllOnDark) || (weSomeOnDark && theyAllOnLight);
        }
        return false;
    }
    isVariantEnd() {
        return this.board[this.turn].isEmpty();
    }
    variantOutcome() {
        if (this.isVariantEnd() || this.isStalemate()) {
            return { winner: this.turn };
        }
        return;
    }
}
exports.Antichess = Antichess;
class KingOfTheHill extends chess_1.Chess {
    constructor() {
        super('kingofthehill');
    }
    static default() {
        return super.default();
    }
    static fromSetup(setup) {
        return super.fromSetup(setup);
    }
    clone() {
        return super.clone();
    }
    hasInsufficientMaterial(_color) {
        return false;
    }
    isVariantEnd() {
        return this.board.king.intersects(squareSet_1.SquareSet.center());
    }
    variantOutcome() {
        for (const color of types_1.COLORS) {
            if (this.board.pieces(color, 'king').intersects(squareSet_1.SquareSet.center()))
                return { winner: color };
        }
        return;
    }
}
exports.KingOfTheHill = KingOfTheHill;
class ThreeCheck extends chess_1.Chess {
    constructor() {
        super('3check');
    }
    static default() {
        const pos = super.default();
        pos.remainingChecks = setup_1.RemainingChecks.default();
        return pos;
    }
    static fromSetup(setup) {
        return super.fromSetup(setup).map(pos => {
            pos.remainingChecks = setup.remainingChecks ? setup.remainingChecks.clone() : setup_1.RemainingChecks.default();
            return pos;
        });
    }
    clone() {
        return super.clone();
    }
    hasInsufficientMaterial(color) {
        return this.board.pieces(color, 'king').equals(this.board[color]);
    }
    isVariantEnd() {
        return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);
    }
    variantOutcome() {
        if (this.remainingChecks) {
            for (const color of types_1.COLORS) {
                if (this.remainingChecks[color] <= 0)
                    return { winner: color };
            }
        }
        return;
    }
}
exports.ThreeCheck = ThreeCheck;
class RacingKings extends chess_1.Chess {
    constructor() {
        super('racingkings');
    }
    static default() {
        const pos = new this();
        pos.board = board_1.Board.racingKings();
        pos.turn = 'white';
        pos.castles = chess_1.Castles.empty();
        pos.epSquare = undefined;
        pos.remainingChecks = undefined;
        pos.halfmoves = 0;
        pos.fullmoves = 1;
        return pos;
    }
    static fromSetup(setup) {
        return super.fromSetup(setup).map(pos => {
            pos.castles = chess_1.Castles.empty();
            return pos;
        });
    }
    validate() {
        if (this.board.pawn.nonEmpty() || this.isCheck()) {
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Variant));
        }
        return super.validate();
    }
    clone() {
        return super.clone();
    }
    dests(square, ctx) {
        // Kings cannot give check.
        if (square === ctx.king)
            return super.dests(square, ctx);
        // TODO: This could be optimized considerably.
        let dests = squareSet_1.SquareSet.empty();
        for (const to of super.dests(square, ctx)) {
            // Valid, because there are no promotions (or even pawns).
            const uci = { from: square, to };
            const after = this.clone();
            after.play(uci);
            if (!after.isCheck())
                dests = dests.with(to);
        }
        return dests;
    }
    hasInsufficientMaterial(_color) {
        return false;
    }
    isVariantEnd() {
        const goal = squareSet_1.SquareSet.fromRank(7);
        const inGoal = this.board.king.intersect(goal);
        if (inGoal.isEmpty())
            return false;
        if (this.turn === 'white' || inGoal.intersects(this.board.black))
            return true;
        // White has reached the backrank. Check if black can catch up.
        const blackKing = this.board.kingOf('black');
        if (util_1.defined(blackKing)) {
            const occ = this.board.occupied.without(blackKing);
            for (const target of attacks_1.kingAttacks(blackKing).intersect(goal).diff(this.board.black)) {
                if (this.kingAttackers(target, util_1.opposite(this.turn), occ).isEmpty())
                    return false;
            }
        }
        return true;
    }
    variantOutcome() {
        if (!this.isVariantEnd())
            return;
        const goal = squareSet_1.SquareSet.fromRank(7);
        const blackInGoal = this.board.pieces('black', 'king').intersects(goal);
        const whiteInGoal = this.board.pieces('white', 'king').intersects(goal);
        if (blackInGoal && !whiteInGoal)
            return { winner: 'black' };
        if (whiteInGoal && !blackInGoal)
            return { winner: 'white' };
        return { winner: undefined };
    }
}
class Horde extends chess_1.Chess {
    constructor() {
        super('horde');
    }
    static default() {
        const pos = new this();
        pos.board = board_1.Board.horde();
        pos.pockets = undefined;
        pos.turn = 'white';
        pos.castles = chess_1.Castles.default();
        pos.castles.discardSide('white');
        pos.epSquare = undefined;
        pos.remainingChecks = undefined;
        pos.halfmoves = 0;
        pos.fullmoves = 1;
        return pos;
    }
    static fromSetup(setup) {
        return super.fromSetup(setup);
    }
    validate() {
        if (this.board.occupied.isEmpty())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Empty));
        if (!this.board.king.isSingleSquare())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Kings));
        if (!this.board.king.diff(this.board.promoted).isSingleSquare())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.Kings));
        const otherKing = this.board.kingOf(util_1.opposite(this.turn));
        if (util_1.defined(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())
            return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.OppositeCheck));
        for (const color of types_1.COLORS) {
            if (this.board.pieces(color, 'pawn').intersects(squareSet_1.SquareSet.backrank(util_1.opposite(color)))) {
                return result_1.Result.err(new chess_1.PositionError(chess_1.IllegalSetup.PawnsOnBackrank));
            }
        }
        return result_1.Result.ok(undefined);
    }
    clone() {
        return super.clone();
    }
    hasInsufficientMaterial(_color) {
        // TODO: Could detect cases where the horde cannot mate.
        return false;
    }
    isVariantEnd() {
        return this.board.white.isEmpty() || this.board.black.isEmpty();
    }
    variantOutcome() {
        if (this.board.white.isEmpty())
            return { winner: 'black' };
        if (this.board.black.isEmpty())
            return { winner: 'white' };
        return;
    }
}
exports.Horde = Horde;
function defaultPosition(rules) {
    switch (rules) {
        case 'chess': return chess_1.Chess.default();
        case 'antichess': return Antichess.default();
        case 'atomic': return Atomic.default();
        case 'horde': return Horde.default();
        case 'racingkings': return RacingKings.default();
        case 'kingofthehill': return KingOfTheHill.default();
        case '3check': return ThreeCheck.default();
        case 'crazyhouse': return Crazyhouse.default();
    }
}
exports.defaultPosition = defaultPosition;
function setupPosition(rules, setup) {
    switch (rules) {
        case 'chess': return chess_1.Chess.fromSetup(setup);
        case 'antichess': return Antichess.fromSetup(setup);
        case 'atomic': return Atomic.fromSetup(setup);
        case 'horde': return Horde.fromSetup(setup);
        case 'racingkings': return RacingKings.fromSetup(setup);
        case 'kingofthehill': return KingOfTheHill.fromSetup(setup);
        case '3check': return ThreeCheck.fromSetup(setup);
        case 'crazyhouse': return Crazyhouse.fromSetup(setup);
    }
}
exports.setupPosition = setupPosition;
